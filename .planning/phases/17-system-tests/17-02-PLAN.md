---
wave: 2
depends_on:
  - 17-01
files_modified:
  - tests/test_system/test_menu_system.py
  - tests/test_system/test_admin_menu.py
autonomous: true
---

# Plan 17-02: Menu System Tests (Admin/VIP/Free with FSM)

## Objective

Create comprehensive tests for the menu system covering Admin, VIP, and Free menus with FSM state management. These tests verify that users can navigate menus correctly, callbacks work, and role-based routing functions properly.

## Context

The bot has a complex menu system with:
- **Admin menu**: Main dashboard with submenus for content, users, interests, VIP, Free
- **VIP menu**: Shows subscription info, premium packages, "Me interesa" buttons
- **Free menu**: Shows available content, social media, VIP channel option
- **Role-based routing**: Automatic detection of Admin/VIP/Free role

**Current State:**
- Handlers use FSM (Finite State Machine) for multi-step flows
- MenuService centralizes keyboard generation
- LucienVoiceService provides all menu messages
- Callback format: `menu:main`, `menu:vip`, `menu:free`, `admin:content`, etc.

**Why This Matters:**
- Menus are the primary user interaction point
- FSM bugs can leave users stuck in states
- Role routing ensures users see correct options
- Callback failures break navigation

## Success Criteria

1. Tests verify admin menu opens with correct options
2. Tests verify VIP/Free menu routing based on user role
3. Tests verify callback navigation works (back buttons, submenu navigation)
4. Tests verify FSM state management (entry and exit)
5. Tests cover edge cases (non-admin trying admin menu, VIP expiry during session)

## Tasks

### Task 1: Create Admin Menu Tests

**File:** `tests/test_system/test_admin_menu.py`

Create tests for admin menu handlers:

```python
# Test 1: Admin /admin command
async def test_admin_command(admin_message, test_session, mock_bot):
    """Verify admin can open main menu."""
    from bot.handlers.admin.main import cmd_admin
    from unittest.mock import AsyncMock

    # Create admin message
    message = admin_message
    message.answer = AsyncMock()

    # Execute handler
    await cmd_admin(message, test_session)

    # Verify response
    message.answer.assert_called_once()
    call_args = message.answer.call_args
    assert call_args is not None

    # Check keyboard contains admin options
    reply_markup = call_args.kwargs.get('reply_markup')
    assert reply_markup is not None

# Test 2: Admin menu callbacks
async def test_admin_main_menu_callback(admin_callback, test_session, mock_bot):
    """Verify admin:main callback works."""
    from bot.handlers.admin.main import callback_admin_main
    from unittest.mock import AsyncMock

    # Create callback
    callback = admin_callback
    callback.data = "admin:main"
    callback.message.edit_text = AsyncMock()
    callback.message.edit_reply_markup = AsyncMock()

    # Execute handler
    await callback_admin_main(callback, test_session)

    # Verify menu updated
    assert callback.message.edit_text.called or callback.message.edit_reply_markup.called

# Test 3: Admin content submenu
async def test_admin_content_menu(admin_callback, test_session, mock_bot):
    """Verify admin can access content management."""
    from unittest.mock import AsyncMock

    callback = admin_callback
    callback.data = "admin:content"
    callback.message.edit_text = AsyncMock()
    callback.message.edit_reply_markup = AsyncMock()

    # Import and execute callback handler
    from bot.handlers.admin.menu_callbacks import handle_content_menu
    await handle_content_menu(callback, test_session, mock_bot)

    # Verify submenu opened
    assert callback.message.edit_text.called or callback.message.edit_reply_markup.called

# Test 4: Non-admin blocked from admin menu
async def test_non_admin_blocked(user_message, test_session, mock_bot):
    """Verify non-admin cannot access admin menu."""
    from bot.handlers.admin.main import cmd_admin
    from unittest.mock import AsyncMock

    # Create non-admin message
    message = user_message
    message.answer = AsyncMock()

    # Execute handler (should be blocked by middleware)
    # Middleware should prevent handler from executing
    # This test verifies the middleware works

    # In actual test, middleware runs before handler
    # So we verify handler doesn't execute
    # We'll test this by checking the message was NOT answered

    # Note: This test requires middleware integration
    # We'll test middleware separately in Task 3
```

### Task 2: Create Role-Based Menu Tests

**File:** `tests/test_system/test_role_menu_routing.py`

Create tests for automatic menu routing based on role:

```python
# Test 1: VIP user gets VIP menu
async def test_vip_user_gets_vip_menu(vip_message, test_session, mock_bot):
    """Verify VIP user sees VIP menu on /start."""
    from bot.handlers.user.start import cmd_start
    from unittest.mock import AsyncMock
    from bot.database.models import VIPSubscriber
    from datetime import datetime, timezone, timedelta

    # Create VIP subscription
    subscriber = VIPSubscriber(
        user_id=vip_message.from_user.id,
        subscribed_at=datetime.now(timezone.utc),
        expires_at=datetime.now(timezone.utc) + timedelta(days=30)
    )
    test_session.add(subscriber)
    await test_session.commit()

    # Execute /start
    vip_message.answer = AsyncMock()
    await cmd_start(vip_message, test_session)

    # Verify VIP-specific message was sent
    vip_message.answer.assert_called()
    call_args = vip_message.answer.call_args
    text = call_args.kwargs.get('text', '')

    # Check for VIP indicators in message
    assert 'VIP' in text or 'premium' in text.lower() or 'dÃ­as restantes' in text.lower()

# Test 2: Free user gets Free menu
async def test_free_user_gets_free_menu(free_message, test_session, mock_bot):
    """Verify free user sees Free menu on /start."""
    from bot.handlers.user.start import cmd_start
    from unittest.mock import AsyncMock

    # Execute /start (no VIP subscription)
    free_message.answer = AsyncMock()
    await cmd_start(free_message, test_session)

    # Verify free user menu was sent
    free_message.answer.assert_called()
    call_args = free_message.answer.call_args

    # Check keyboard has Free options
    reply_markup = call_args.kwargs.get('reply_markup')
    assert reply_markup is not None

# Test 3: Admin gets admin redirect on /start
async def test_admin_start_redirects_to_admin(admin_message, test_session, mock_bot):
    """Verify admin is redirected to /admin on /start."""
    from bot.handlers.user.start import cmd_start
    from unittest.mock import AsyncMock
    from config import Config

    # Ensure user is admin
    admin_id = admin_message.from_user.id
    # Config.is_admin would return True for this user

    # Execute /start
    admin_message.answer = AsyncMock()
    await cmd_start(admin_message, test_session)

    # Verify admin-specific message
    admin_message.answer.assert_called()
    call_args = admin_message.answer.call_args
    text = call_args.kwargs.get('text', '')

    # Should mention admin panel or redirect
    assert 'admin' in text.lower() or 'panel' in text.lower()
```

### Task 3: Create VIP/Free Menu Tests

**File:** `tests/test_system/test_vip_free_menus.py`

Create tests for VIP and Free user menus:

```python
# Test 1: VIP menu shows subscription info
async def test_vip_menu_shows_subscription_info(vip_callback, test_session, mock_bot):
    """Verify VIP menu displays subscription details."""
    from bot.handlers.vip.menu import handle_vip_menu
    from unittest.mock import AsyncMock
    from bot.database.models import VIPSubscriber
    from datetime import datetime, timezone, timedelta

    # Create VIP subscription
    subscriber = VIPSubscriber(
        user_id=vip_callback.from_user.id,
        subscribed_at=datetime.now(timezone.utc),
        expires_at=datetime.now(timezone.utc) + timedelta(days=15)
    )
    test_session.add(subscriber)
    await test_session.commit()

    # Execute VIP menu callback
    vip_callback.message.edit_text = AsyncMock()
    vip_callback.message.edit_reply_markup = AsyncMock()

    await handle_vip_menu(vip_callback, test_session, mock_bot)

    # Verify menu shows subscription info
    assert vip_callback.message.edit_text.called

# Test 2: VIP menu has "Premium" option
async def test_vip_menu_has_premium_option(vip_callback, test_session, mock_bot):
    """Verify VIP menu includes premium content option."""
    from bot.handlers.vip.menu import handle_vip_menu
    from unittest.mock import AsyncMock

    vip_callback.message.edit_text = AsyncMock()
    vip_callback.message.edit_reply_markup = AsyncMock()

    await handle_vip_menu(vip_callback, test_session, mock_bot)

    # Check keyboard has premium option
    call_args = vip_callback.message.edit_reply_markup.call_args
    if call_args:
        reply_markup = call_args.kwargs.get('reply_markup')
        # Verify premium button exists
        assert reply_markup is not None

# Test 3: Free menu has social media option
async def test_free_menu_has_social_media(free_callback, test_session, mock_bot):
    """Verify Free menu includes social media option."""
    from bot.handlers.free.menu import handle_free_menu
    from unittest.mock import AsyncMock

    free_callback.message.edit_text = AsyncMock()
    free_callback.message.edit_reply_markup = AsyncMock()

    await handle_free_menu(free_callback, test_session, mock_bot)

    # Verify menu includes social media
    assert free_callback.message.edit_text.called or free_callback.message.edit_reply_markup.called

# Test 4: Free menu has "Canal VIP" option
async def test_free_menu_has_vip_channel_option(free_callback, test_session, mock_bot):
    """Verify Free menu includes VIP channel access option."""
    from bot.handlers.free.menu import handle_free_menu
    from unittest.mock import AsyncMock

    free_callback.message.edit_text = AsyncMock()
    free_callback.message.edit_reply_markup = AsyncMock()

    await handle_free_menu(free_callback, test_session, mock_bot)

    # Verify VIP channel option exists
    call_args = free_callback.message.edit_reply_markup.call_args
    if call_args:
        reply_markup = call_args.kwargs.get('reply_markup')
        assert reply_markup is not None

# Test 5: Menu navigation - back button works
async def test_menu_back_button_navigation(callback, test_session, mock_bot):
    """Verify back button returns to previous menu."""
    from unittest.mock import AsyncMock

    # Simulate being in submenu
    callback.data = "menu:main"  # Back to main menu
    callback.message.edit_text = AsyncMock()
    callback.message.edit_reply_markup = AsyncMock()

    # Import and execute back button handler
    from bot.handlers.user.start import handle_main_menu_callback
    await handle_main_menu_callback(callback, test_session, mock_bot)

    # Verify returned to main menu
    assert callback.message.edit_text.called or callback.message.edit_reply_markup.called
```

### Task 4: Create FSM State Management Tests

**File:** `tests/test_system/test_fsm_states.py`

Create tests for FSM state handling:

```python
# Test 1: FSM state is set on menu entry
async def test_fsm_state_set_on_entry(callback, test_session, mock_bot):
    """Verify FSM state is set when entering a flow."""
    from aiogram.fsm.context import FSMContext
    from bot.states.user import UserMenuStates
    from unittest.mock import AsyncMock

    callback.data = "menu:vip"
    callback.message.edit_text = AsyncMock()
    callback.message.edit_reply_markup = AsyncMock()

    # Mock FSM context
    fsm_state = FSMContext(storage=mock_bot.dispatcher.storage, key=callback.from_user.id)

    # Execute handler that should set state
    from bot.handlers.vip.menu import handle_vip_menu
    await handle_vip_menu(callback, test_session, mock_bot)

    # Verify state was set (if applicable)
    # Note: Not all menu handlers set FSM state
    # This test is for handlers that DO use FSM

# Test 2: FSM state is cleared on exit
async def test_fsm_state_cleared_on_exit(callback, test_session, mock_bot):
    """Verify FSM state is cleared when exiting a flow."""
    from aiogram.fsm.context import FSMContext
    from bot.states.user import UserMenuStates
    from unittest.mock import AsyncMock

    # Mock FSM context with existing state
    fsm_state = FSMContext(storage=mock_bot.dispatcher.storage, key=callback.from_user.id)
    await fsm_state.set_state(UserMenuStates.browsing_packages)

    # Execute callback that should clear state (e.g., cancel button)
    callback.data = "menu:main"
    callback.message.edit_text = AsyncMock()
    callback.message.edit_reply_markup = AsyncMock()

    from bot.handlers.user.start import handle_main_menu_callback
    await handle_main_menu_callback(callback, test_session, mock_bot)

    # Verify state was cleared
    current_state = await fsm_state.get_state()
    assert current_state is None

# Test 3: FSM state persists across callback chain
async def test_fsm_state_persists_across_callbacks(callback, test_session, mock_bot):
    """Verify FSM state persists through multi-step flows."""
    from aiogram.fsm.context import FSMContext
    from bot.states.user import UserMenuStates
    from unittest.mock import AsyncMock

    fsm_state = FSMContext(storage=mock_bot.dispatcher.storage, key=callback.from_user.id)

    # Simulate multi-step flow (e.g., content package creation)
    # Step 1: Enter flow
    callback.data = "admin:content:create"
    await fsm_state.set_state(UserMenuStates.browsing_packages)

    # Step 2: Next step
    callback.data = "admin:content:set_title"
    current_state = await fsm_state.get_state()
    assert current_state == UserMenuStates.browsing_packages

    # Step 3: Complete flow
    callback.data = "menu:main"
    # State should be cleared

# Test 4: Invalid callback in wrong state is rejected
async def test_invalid_callback_rejected(callback, test_session, mock_bot):
    """Verify callbacks are rejected when in wrong FSM state."""
    from aiogram.fsm.context import FSMContext
    from bot.states.user import UserMenuStates
    from unittest.mock import AsyncMock
    import pytest

    fsm_state = FSMContext(storage=mock_bot.dispatcher.storage, key=callback.from_user.id)

    # Set state to "browsing_packages"
    await fsm_state.set_state(UserMenuStates.browsing_packages)

    # Try to execute callback for different state
    callback.data = "admin:content:edit"  # Requires different state
    callback.answer = AsyncMock()

    # Handler should reject with error message
    # (specific implementation depends on handler)
```

## New Fixtures Required

Add to `tests/fixtures/telegram.py`:

```python
import pytest
from aiogram.types import Message, CallbackQuery, User, Chat
from unittest.mock import AsyncMock

@pytest.fixture
def admin_user():
    """Create admin user for testing."""
    return User(id=123456789, is_bot=False, first_name="Admin", username="admin_user")

@pytest.fixture
def vip_user():
    """Create VIP user for testing."""
    return User(id=987654321, is_bot=False, first_name="VIP", username="vip_user")

@pytest.fixture
def free_user():
    """Create free user for testing."""
    return User(id=111222333, is_bot=False, first_name="Free", username="free_user")

@pytest.fixture
def admin_message(admin_user):
    """Create admin message."""
    chat = Chat(id=123456789, type="private")
    message = Message(
        message_id=1,
        date=None,
        chat=chat,
        from_user=admin_user,
        content_type="text",
        options={}
    )
    message.text = "/admin"
    message.bot = AsyncMock()
    return message

@pytest.fixture
def vip_message(vip_user):
    """Create VIP user message."""
    chat = Chat(id=987654321, type="private")
    message = Message(
        message_id=1,
        date=None,
        chat=chat,
        from_user=vip_user,
        content_type="text",
        options={}
    )
    message.text = "/start"
    message.bot = AsyncMock()
    return message

@pytest.fixture
def free_message(free_user):
    """Create free user message."""
    chat = Chat(id=111222333, type="private")
    message = Message(
        message_id=1,
        date=None,
        chat=chat,
        from_user=free_user,
        content_type="text",
        options={}
    )
    message.text = "/start"
    message.bot = AsyncMock()
    return message

@pytest.fixture
def admin_callback(admin_user):
    """Create admin callback query."""
    callback = CallbackQuery(
        id="test_admin_callback",
        from_user=admin_user,
        chat_instance="test",
        data="admin:main"
    )
    callback.message = AsyncMock()
    callback.message.edit_text = AsyncMock()
    callback.message.edit_reply_markup = AsyncMock()
    callback.answer = AsyncMock()
    callback.bot = AsyncMock()
    return callback

@pytest.fixture
def vip_callback(vip_user):
    """Create VIP user callback."""
    callback = CallbackQuery(
        id="test_vip_callback",
        from_user=vip_user,
        chat_instance="test",
        data="menu:vip"
    )
    callback.message = AsyncMock()
    callback.message.edit_text = AsyncMock()
    callback.message.edit_reply_markup = AsyncMock()
    callback.answer = AsyncMock()
    callback.bot = AsyncMock()
    return callback

@pytest.fixture
def free_callback(free_user):
    """Create free user callback."""
    callback = CallbackQuery(
        id="test_free_callback",
        from_user=free_user,
        chat_instance="test",
        data="menu:free"
    )
    callback.message = AsyncMock()
    callback.message.edit_text = AsyncMock()
    callback.message.edit_reply_markup = AsyncMock()
    callback.answer = AsyncMock()
    callback.bot = AsyncMock()
    return callback
```

## Verification

**Manual Verification:**
1. Run `pytest tests/test_system/test_admin_menu.py -v` and verify all admin menu tests pass
2. Run `pytest tests/test_system/test_role_menu_routing.py -v` and verify role routing works
3. Run `pytest tests/test_system/test_vip_free_menus.py -v` and verify VIP/Free menus work
4. Run `pytest tests/test_system/test_fsm_states.py -v` and verify FSM state management

**Automated Verification:**
- All menu tests pass without errors
- Coverage for menu handlers > 75%
- Tests complete in < 45 seconds

## Anti-Patterns to Avoid

1. **Don't test FSM internals directly** - Test observable state changes, not implementation
2. **Don't skip callback answer** - Always call `callback.answer()` in tests
3. **Don't ignore keyboard validation** - Verify buttons are present and correct
4. **Don't forget to mock message methods** - answer(), edit_text(), edit_reply_markup()
5. **Don't test message text content** - Messages come from LucienVoiceService, test those separately
6. **Don't skip role testing** - Verify each role sees correct options

## Notes

- Use FSMContext fixture for state testing
- Mock bot.dispatcher.storage for FSM state persistence
- Test callbacks with data parameter matching actual callback format
- Verify keyboard structure, not exact button text (text can change)
- Focus on behavior, not message content (content is tested in plan 17-04)

## References

- Admin handlers: `bot/handlers/admin/`
- VIP handlers: `bot/handlers/vip/`
- Free handlers: `bot/handlers/free/`
- User handlers: `bot/handlers/user/`
- FSM states: `bot/states/`
- MenuService: `bot/services/menu.py`
