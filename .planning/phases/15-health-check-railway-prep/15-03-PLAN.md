---
phase: 15-health-check-railway-prep
plan: 15-03
type: execute
wave: 3
depends_on: [15-02]
files_modified:
  - Railway.toml
  - Dockerfile
  - .dockerignore
autonomous: true
must_haves:
  truths:
    - "Railway.toml configured with health check path /health on port 8000"
    - "Dockerfile creates production-ready image with all dependencies"
    - "Dockerfile uses multi-stage build for smaller image size"
    - "Dockerfile sets appropriate non-root user for security"
    - "Health check endpoint accessible to Railway monitoring system"
    - "Bot starts automatically on Railway deployment"
  artifacts:
    - path: "Railway.toml"
      provides: "Railway deployment configuration"
      min_lines: 15
      contains: ["[build]", "[deploy]", "healthcheckPath", "healthcheckPort"]
    - path: "Dockerfile"
      provides: "Production Docker image for Railway deployment"
      min_lines: 40
      contains: ["FROM python:", "WORKDIR", "COPY", "RUN pip install", "CMD", "USER"]
    - path: ".dockerignore"
      provides: "Docker build optimization (excludes unnecessary files)"
      min_lines: 15
      contains: ["__pycache__", "*.pyc", ".env", ".git", "bot.db"]
  key_links:
    - from: "Railway.toml"
      to: "Dockerfile"
      via: "build config references Dockerfile"
      pattern: "dockerfile"
    - from: "Railway.toml"
      to: "bot/health/endpoints.py"
      via: "healthcheckPath references /health endpoint"
      pattern: "healthcheckPath"
    - from: "Dockerfile"
      to: "requirements.txt"
      via: "COPY requirements.txt for dependency installation"
      pattern: "COPY requirements.txt"
---

# Plan 15-03: Railway.toml and Dockerfile Configuration

**Wave:** 3
**Depends on:** Plan 15-02 (Concurrent bot and health API execution)

---

## Overview

Create Railway deployment configuration files including Railway.toml for deployment settings and Dockerfile for container image. The configuration will enable Railway's health monitoring system to check the /health endpoint and ensure the bot is running correctly. This plan prepares the deployment infrastructure but does NOT execute the actual deployment.

---

## Tasks

<task type="auto">
  <name>Task 1: Create Railway.toml configuration</name>
  <files>Railway.toml</files>
  <action>Create `Railway.toml` in project root:

```toml
# Railway Deployment Configuration
# See: https://docs.railway.app/reference/railway-toml

[build]
# Dockerfile to use for building the image
dockerfile = "Dockerfile"

[deploy]
# Start command (optional if Dockerfile has CMD)
# healthcheckCmd runs in the container to verify health
healthcheckPath = "/health"
healthcheckPort = 8000
healthcheckTimeout = 300
# Number of seconds to wait for health check before restart
healthcheckInterval = 30

# Auto-restart on failure
restartPolicyType = "ON_FAILURE"
# Maximum number of restarts before giving up
maxRestartRetries = 10
```

Key configuration points:
- healthcheckPath: "/health" matches our FastAPI endpoint
- healthcheckPort: 8000 matches Config.HEALTH_PORT default
- healthcheckTimeout: 300s (5 min) allows time for DB migrations and bot startup
- restartPolicyType: "ON_FAILURE" restarts bot if it crashes
</action>
  <verify>cat Railway.toml shows valid TOML with [build] and [deploy] sections</verify>
  <done>
- Railway.toml created in project root
- [build] section references Dockerfile
- [deploy] section has healthcheckPath="/health" and healthcheckPort=8000
- healthcheckTimeout and restartPolicy configured appropriately
</done>
</task>

<task type="auto">
  <name>Task 2: Create production Dockerfile</name>
  <files>Dockerfile</files>
  <action>Create `Dockerfile` in project root using multi-stage build:

```dockerfile
# Stage 1: Builder
FROM python:3.11-slim AS builder

# Set working directory
WORKDIR /app

# Install system dependencies
RUN apt-get update && apt-get install -y \
    build-essential \
    && rm -rf /var/lib/apt/lists/*

# Copy requirements first for caching
COPY requirements.txt .

# Install Python dependencies
RUN pip install --no-cache-dir --user -r requirements.txt

# Stage 2: Runtime
FROM python:3.11-slim

# Set working directory
WORKDIR /app

# Create non-root user for security
RUN groupadd -r botuser && useradd -r -g botuser botuser

# Copy installed packages from builder
COPY --from=builder /root/.local /root/.local

# Make sure scripts in .local are usable
ENV PATH=/root/.local/bin:$PATH

# Copy application code
COPY . .

# Create data directory for SQLite (if needed)
RUN mkdir -p /data && chown -R botuser:botuser /data

# Switch to non-root user
USER botuser

# Environment variables
ENV PYTHONUNBUFFERED=1
ENV PYTHONDONTWRITEBYTECODE=1
ENV PORT=8000

# Expose health check port
EXPOSE 8000

# Health check (internal Docker health check)
HEALTHCHECK --interval=30s --timeout=10s --start-period=60s --retries=3 \
    CMD python -c "import urllib.request; urllib.request.urlopen('http://localhost:8000/health')"

# Run the application
CMD ["python", "main.py"]
```

Key points:
- Multi-stage build for smaller image
- Non-root user for security
- HEALTHCHECK directive for Docker health monitoring
- Proper PYTHONUNBUFFERED for logging
- Exposes port 8000 for health checks
</action>
  <verify>docker build -t adminpro-test . --no-cache succeeds (if Docker available)</verify>
  <done>
- Dockerfile uses multi-stage build (builder + runtime)
- Non-root user (botuser) created and used
- HEALTHCHECK directive tests /health endpoint
- CMD runs python main.py
- Exposes port 8000
- Copies application code correctly
</done>
</task>

<task type="auto">
  <name>Task 3: Create .dockerignore for build optimization</name>
  <files>.dockerignore</files>
  <action>Create `.dockerignore` in project root:

```
# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python

# Virtual environments
venv/
env/
ENV/
.venv

# Environment files (will be set in Railway)
.env
.env.local

# Database files (local development)
bot.db
bot.db-shm
bot.db-wal
*.db
*.db-shm
*.db-wal

# Git
.git/
.gitignore
.gitattributes

# Documentation
README.md
docs/
*.md
.planning/

# IDE
.vscode/
.idea/
*.swp
*.swo
*~

# OS
.DS_Store
Thumbs.db

# Logs
*.log
logs/

# Testing
.pytest_cache/
.coverage
htmlcov/
.tox/

# Temporary files
*.tmp
*.bak
*.backup
bot.db.backup

# Claude/AI files
.claude/
```

This reduces image size and prevents sensitive/unnecessary files from being copied.
</action>
  <verify>cat .dockerignore shows reasonable exclusions for Python project</verify>
  <done>
- .dockerignore excludes Python cache files
- .dockerignore excludes .env and local databases
- .dockerignore excludes .git and documentation
- .dockerignore excludes IDE and OS files
- .dockerignore excludes logs and testing artifacts
</done>
</task>

<task type="auto">
  <name>Task 4: Add Railway environment variable documentation</name>
  <files>.env.example</files>
  <action>Add Railway-specific environment variables to .env.example:

Add a new section at the end:

```bash
# ===== RAILWAY DEPLOYMENT =====
# These are set automatically by Railway when deployed
# Do NOT set these locally unless testing Railway behavior

# Port that Railway expects the app to listen on
# PORT=8000  # (set by Railway automatically)

# Railway database URL (PostgreSQL)
# DATABASE_URL=postgresql://postgres:password@hostname.railway.app:5432/railway

# Environment (production/development)
# ENV=production  # Set to production on Railway
```

Also update the existing DATABASE_URL section to reference Railway:
```bash
# ===== DATABASE =====
# Local development (SQLite)
# DATABASE_URL=sqlite+aiosqlite:///bot.db
# DATABASE_URL=sqlite:///bot.db

# Production (PostgreSQL on Railway)
# DATABASE_URL=postgresql://postgres:password@hostname.railway.app:5432/railway
# DATABASE_URL=postgresql+asyncpg://postgres:password@hostname.railway.app:5432/railway

# Default (fallback to SQLite if not set)
DATABASE_URL=sqlite+aiosqlite:///bot.db
```
</action>
  <verify>grep -E "(RAILWAY|PORT)" .env.example shows Railway-specific variables</verify>
  <done>
- .env.example documents Railway PORT variable
- .env.example documents Railway DATABASE_URL format
- .env.example includes ENV=production for Railway
- Existing DATABASE_URL examples reference Railway
</done>
</task>

<task type="auto">
  <name>Task 5: Create Railway deployment README section</name>
  <files>README.md</files>
  <action>Add a "Railway Deployment" section to README.md:

Add after the existing documentation sections:

```markdown
## Railway Deployment

This bot is configured for deployment on Railway with the following features:

### Health Monitoring

- **Health Check Endpoint**: `http://your-app.railway.app/health`
- **Health Check Port**: 8000 (configurable via `HEALTH_PORT`)
- **Health Check Timeout**: 300s (allows time for DB migrations)
- **Auto-restart**: Enabled on failure

### Environment Variables (Railway)

Required environment variables in Railway:

- `BOT_TOKEN`: Telegram bot token
- `ADMIN_USER_IDS`: Comma-separated admin user IDs
- `DATABASE_URL`: PostgreSQL connection string (Railway provides this)
- `ENV`: Set to `production` for auto-migrations on startup
- `PORT`: Automatically set by Railway to 8000

Optional environment variables:

- `HEALTH_PORT`: Health check API port (default: 8000)
- `HEALTH_HOST`: Health check API host (default: 0.0.0.0)
- `LOG_LEVEL`: Logging level (default: INFO)

### Deployment Steps

1. Create a new project on Railway
2. Link your GitHub repository
3. Add required environment variables in Railway dashboard
4. Deploy! Railway will automatically detect the Railway.toml and Dockerfile

### Database

- **Local**: SQLite (default) - requires no setup
- **Railway**: PostgreSQL - provisioned automatically
- **Migrations**: Auto-run on production startup (`ENV=production`)

### Monitoring

Check the `/health` endpoint to verify bot status:

\`\`\`bash
curl https://your-app.railway.app/health
\`\`\`

Expected response (200 OK):
\`\`\`json
{
  "status": "healthy",
  "timestamp": "2024-01-28T12:00:00Z",
  "components": {
    "bot": "healthy",
    "database": "healthy"
  }
}
\`\`\`
```

Add proper indentation and formatting to match existing README style.
</action>
  <verify>grep -A 5 "Railway Deployment" README.md shows the new section</verify>
  <done>
- README.md has "Railway Deployment" section
- Documents health check endpoint and port
- Lists all required and optional environment variables
- Includes deployment steps
- Shows health check example with expected response
</done>
</task>

---

## Verification Criteria

**Must-haves (goal-backward verification):**

1. ✅ Railway.toml configured with health check path /health on port 8000 (RAIL-01)
   - Test: `cat Railway.toml` shows `healthcheckPath = "/health"`
   - Test: `cat Railway.toml` shows `healthcheckPort = 8000`

2. ✅ Dockerfile creates production-ready image with all dependencies (RAIL-02)
   - Test: `docker build -t adminpro-test .` succeeds (if Docker available)
   - Test: Image includes all requirements.txt dependencies
   - Test: Image includes application code

3. ✅ Dockerfile uses multi-stage build for smaller image size
   - Test: `docker history adminpro-test` shows builder and runtime stages
   - Test: Final image size is reasonable (< 200MB)

4. ✅ Dockerfile sets appropriate non-root user for security
   - Test: Dockerfile creates `botuser` group and user
   - Test: Dockerfile switches to `USER botuser` before CMD

5. ✅ Health check endpoint accessible to Railway monitoring system (HEALTH-04)
   - Test: Railway.toml references correct healthcheckPath and healthcheckPort
   - Test: Dockerfile HEALTHCHECK directive uses /health endpoint

6. ✅ Bot starts automatically on Railway deployment (RAIL-02)
   - Test: Dockerfile CMD is `["python", "main.py"]`
   - Test: No interactive or manual steps required

---

## Success Metrics

- ✅ Railway.toml is valid TOML with all required sections
- ✅ Dockerfile builds successfully without errors
- ✅ Docker image size is optimized (multi-stage build)
- ✅ All required environment variables are documented
- ✅ Health check configuration matches FastAPI endpoint
- ✅ README.md provides clear deployment instructions

---

## Output

After completion, create `.planning/phases/15-health-check-railway-prep/15-03-SUMMARY.md`
