---
phase: 15-health-check-railway-prep
plan: 15-04
type: execute
wave: 4
depends_on: [15-03]
files_modified:
  - config.py
  - main.py
  - .env.example
autonomous: true
must_haves:
  truths:
    - "Config validates all required environment variables on startup"
    - "Config provides clear error messages for missing or invalid variables"
    - "Bot can switch between polling and webhook modes via WEBHOOK_MODE env var"
    - "Webhook mode uses PORT env variable for webhook URL"
    - "Polling mode is default for local development"
    - "Health check API works in both polling and webhook modes"
  artifacts:
    - path: "config.py"
      provides: "Enhanced environment variable validation"
      contains: ["validate()", "validate_required_vars", "WEBHOOK_MODE", "PORT"]
    - path: "main.py"
      provides: "Webhook/polling mode detection and startup logic"
      contains: ["should_use_webhook", "start_webhook", "start_polling"]
    - path: ".env.example"
      provides: "Complete environment variable documentation"
      contains: ["WEBHOOK_MODE", "PORT", "WEBHOOK_SECRET"]
  key_links:
    - from: "main.py"
      to: "config.py"
      via: "Config.WEBHOOK_MODE, Config.PORT"
      pattern: "Config\\.(WEBHOOK_MODE|PORT)"
    - from: "main.py"
      to: "aiogram"
      via: "dp.start_webhook() or dp.start_polling()"
      pattern: "start_webhook|start_polling"
    - from: "config.py"
      to: ".env.example"
      via: "Environment variable documentation matches validation"
      pattern: "WEBHOOK_MODE|PORT"
---

# Plan 15-04: Environment Variable Validation and Webhook/Polling Mode Switching

**Wave:** 4
**Depends on:** Plan 15-03 (Railway.toml and Dockerfile configuration)

---

## Overview

Implement comprehensive environment variable validation and support for both polling and webhook modes. Polling mode is the default for local development, while webhook mode is optimized for Railway deployment. The bot will automatically detect which mode to use based on the `WEBHOOK_MODE` environment variable and configure itself accordingly.

---

## Tasks

<task type="auto">
  <name>Task 1: Add webhook mode configuration to Config</name>
  <files>config.py</files>
  <action>Add webhook-related environment variables to Config class:

Add after the "ENVIRONMENT" section:

```python
# ===== WEBHOOK CONFIGURATION =====
# Modo de operaciÃ³n: "polling" (default) o "webhook" (Railway)
# Polling: El bot hace requests a Telegram (bueno para desarrollo local)
# Webhook: Telegram envÃ­a updates al bot (bueno para producciÃ³n en Railway)
WEBHOOK_MODE: str = os.getenv("WEBHOOK_MODE", "polling").lower()

# Puerto donde el bot escucha (solo usado en webhook mode)
# Railway asigna este puerto automÃ¡ticamente
PORT: int = int(os.getenv("PORT", "8000"))

# Secret token para validar webhooks de Telegram (seguridad)
# Genera uno seguro para producciÃ³n: python -c "import secrets; print(secrets.token_urlsafe(32))"
WEBHOOK_SECRET: Optional[str] = os.getenv("WEBHOOK_SECRET", None)

# Webhook path (URL path donde Telegram envÃ­a updates)
WEBHOOK_PATH: str = os.getenv("WEBHOOK_PATH", "/webhook")
```

Add validation in validate() method:

```python
# Validar WEBHOOK_MODE
if cls.WEBHOOK_MODE not in ["polling", "webhook"]:
    errors.append(f"WEBHOOK_MODE invÃ¡lido: '{cls.WEBHOOK_MODE}'. Debe ser 'polling' o 'webhook'")

# Validar PORT si estÃ¡ en webhook mode
if cls.WEBHOOK_MODE == "webhook":
    if not (1 <= cls.PORT <= 65535):
        errors.append(f"PORT invÃ¡lido: {cls.PORT}. Debe estar entre 1 y 65535")

# Validar WEBHOOK_SECRET en webhook mode (opcional pero recomendado)
if cls.WEBHOOK_MODE == "webhook" and not cls.WEBHOOK_SECRET:
    logger.warning("âš ï¸ WEBHOOK_SECRET no configurado en modo webhook. Se recomienda para seguridad.")
```

Update get_summary() to include webhook info:
```python
ðŸ”„ Modo: {cls.WEBHOOK_MODE.upper()}
{'ðŸ”— Webhook: port ' + str(cls.PORT) if cls.WEBHOOK_MODE == 'webhook' else ''}
```
</action>
  <verify>
```python
from config import Config

# Test defaults
assert Config.WEBHOOK_MODE == "polling"
assert Config.PORT == 8000

# Test validation
Config.WEBHOOK_MODE = "invalid"
assert "WEBHOOK_MODE invÃ¡lido" in Config.validate()
```
</verify>
  <done>
- Config.WEBHOOK_MODE defaults to "polling"
- Config.PORT defaults to 8000 (Railway's default)
- Config.WEBHOOK_SECRET is optional but logged when missing
- Config.validate() checks WEBHOOK_MODE is valid
- Config.validate() checks PORT is valid range in webhook mode
- get_summary() includes mode and webhook info
</done>
</task>

<task type="auto">
  <name>Task 2: Add enhanced environment variable validation</name>
  <files>config.py</files>
  <action>Add comprehensive environment variable validation to Config:

Add a new method `validate_required_vars()`:

```python
@classmethod
def validate_required_vars(cls) -> tuple[bool, list[str]]:
    """
    Valida que TODAS las variables de entorno requeridas estÃ©n configuradas.

    Returns:
        Tuple de (is_valid, missing_vars)
        - is_valid: True si todas las variables requeridas estÃ¡n presentes
        - missing_vars: Lista de nombres de variables faltantes
    """
    required_vars = {
        "BOT_TOKEN": cls.BOT_TOKEN,
        "DATABASE_URL": cls.DATABASE_URL,
    }

    # Validar que Admin IDs estÃ©n configurados
    cls.load_admin_ids()
    if not cls.ADMIN_USER_IDS:
        required_vars["ADMIN_USER_IDS"] = None

    missing = [name for name, value in required_vars.items() if not value]

    if missing:
        logger.error(f"âŒ Variables requeridas faltantes: {', '.join(missing)}")
        return False, missing

    logger.info("âœ… Todas las variables requeridas estÃ¡n configuradas")
    return True, []
```

Update the existing `validate()` method to use this:

```python
@classmethod
def validate(cls) -> bool:
    """
    Valida que la configuraciÃ³n mÃ­nima estÃ© presente.

    Requerido:
    - BOT_TOKEN
    - Al menos 1 ADMIN_USER_ID
    - DATABASE_URL con formato vÃ¡lido

    Returns:
        True si configuraciÃ³n es vÃ¡lida, False en caso contrario
    """
    errors = []

    # Validar variables requeridas
    is_valid, missing = cls.validate_required_vars()
    if not is_valid:
        errors.append(f"Faltan variables requeridas: {', '.join(missing)}")

    # Validar formato de BOT_TOKEN
    if cls.BOT_TOKEN and len(cls.BOT_TOKEN) < 20:
        errors.append("BOT_TOKEN parece invÃ¡lido (muy corto)")

    # Validar DATABASE_URL
    if cls.DATABASE_URL and not cls.validate_database_url():
        errors.append("DATABASE_URL tiene formato invÃ¡lido")

    # Validar DEFAULT_WAIT_TIME_MINUTES
    if cls.DEFAULT_WAIT_TIME_MINUTES < 1:
        errors.append("DEFAULT_WAIT_TIME_MINUTES debe ser >= 1")

    # Validar WEBHOOK_MODE
    if cls.WEBHOOK_MODE not in ["polling", "webhook"]:
        errors.append(f"WEBHOOK_MODE invÃ¡lido: '{cls.WEBHOOK_MODE}'. Debe ser 'polling' o 'webhook'")

    # Validar PORT si estÃ¡ en webhook mode
    if cls.WEBHOOK_MODE == "webhook" and not (1 <= cls.PORT <= 65535):
        errors.append(f"PORT invÃ¡lido: {cls.PORT}. Debe estar entre 1 y 65535")

    # Reportar errores
    if errors:
        logger.error("âŒ Errores de configuraciÃ³n:")
        for error in errors:
            logger.error(f"  - {error}")
        return False

    logger.info("âœ… ConfiguraciÃ³n validada correctamente")
    return True
```

This provides better error messages and validates all required vars before startup.
</action>
  <verify>
```python
from config import Config

# Test with missing vars
Config.BOT_TOKEN = ""
is_valid, missing = Config.validate_required_vars()
assert not is_valid
assert "BOT_TOKEN" in missing

# Test with all vars present (in real environment)
# Config.BOT_TOKEN = "valid_token..."
# is_valid, missing = Config.validate_required_vars()
# assert is_valid
```
</verify>
  <done>
- validate_required_vars() checks BOT_TOKEN, DATABASE_URL, ADMIN_USER_IDS
- validate_required_vars() returns (is_valid, missing_vars) tuple
- validate() uses validate_required_vars() for better error messages
- All validation errors are logged with clear descriptions
</done>
</task>

<task type="auto">
  <name>Task 3: Implement webhook/polling mode detection in main.py</name>
  <files>main.py</files>
  <action>Modify main.py to support both polling and webhook modes:

1. Add helper function after `_get_bot_info_with_retry()`:

```python
def should_use_webhook() -> bool:
    """
    Detecta si el bot debe ejecutarse en modo webhook.

    Returns:
        True si WEBHOOK_MODE=webhook, False para polling
    """
    return Config.WEBHOOK_MODE == "webhook"
```

2. Create webhook startup function:

```python
async def on_startup_webhook(bot: Bot, dispatcher: Dispatcher) -> None:
    """
    Callback de startup especÃ­fico para modo webhook.

    Configura el webhook antes de iniciar el servidor.
    """
    logger.info("ðŸš€ Iniciando bot en modo WEBHOOK...")

    # Validar configuraciÃ³n
    if not Config.validate():
        logger.error("âŒ ConfiguraciÃ³n invÃ¡lida. Revisa tu archivo .env")
        sys.exit(1)

    logger.info(Config.get_summary())

    # Ejecutar migraciones automÃ¡ticas
    try:
        await run_migrations_if_needed()
    except Exception as e:
        logger.error(f"âŒ Error ejecutando migraciones: {e}")
        sys.exit(1)

    # Inicializar base de datos
    try:
        await init_db()
    except Exception as e:
        logger.error(f"âŒ Error al inicializar BD: {e}")
        sys.exit(1)

    # Iniciar background tasks
    start_background_tasks(bot)

    # Configurar webhook
    webhook_url = f"{Config.WEBHOOK_BASE_URL}{Config.WEBHOOK_PATH}"
    logger.info(f"ðŸ”— Configurando webhook: {webhook_url}")

    try:
        await bot.set_webhook(
            url=webhook_url,
            secret_token=Config.WEBHOOK_SECRET,
            drop_pending_updates=True
        )
        logger.info("âœ… Webhook configurado correctamente")
    except Exception as e:
        logger.error(f"âŒ Error configurando webhook: {e}")
        sys.exit(1)

    # Iniciar health check API
    try:
        health_task = start_health_server()
        dp.workflow_data['health_task'] = health_task
        logger.info("âœ… Health check API iniciado")
    except Exception as e:
        logger.error(f"âŒ Error iniciando health API: {e}")
        logger.warning("âš ï¸ Bot continuarÃ¡ sin health check endpoint")
```

3. Modify main() to detect mode and start appropriately:

```python
async def main() -> None:
    """
    FunciÃ³n principal que ejecuta el bot.

    Soporta dos modos:
    - Polling: Bot hace requests a Telegram (default para desarrollo)
    - Webhook: Telegram envÃ­a updates al bot (Ã³ptimo para Railway)
    """
    # Crear instancia del bot
    session = AiohttpSession(timeout=120)
    bot = Bot(
        token=Config.BOT_TOKEN,
        session=session,
        default=DefaultBotProperties(parse_mode="HTML")
    )

    # Crear storage y dispatcher
    storage = MemoryStorage()
    dp = Dispatcher(storage=storage)

    # Registrar middlewares
    from bot.middlewares import DatabaseMiddleware, RoleDetectionMiddleware
    dp.update.middleware(DatabaseMiddleware())
    dp.update.middleware(RoleDetectionMiddleware())

    # Registrar handlers
    from bot.handlers import register_all_handlers
    register_all_handlers(dp)

    # Detectar modo de operaciÃ³n
    use_webhook = should_use_webhook()

    if use_webhook:
        logger.info("ðŸ”„ Iniciando en modo WEBHOOK...")
        # Registrar callbacks de webhook
        dp.startup.register(on_startup_webhook)
        dp.shutdown.register(on_shutdown)

        # Iniciar webhook server
        await dp.start_webhook(
            bot,
            webhook_path=Config.WEBHOOK_PATH,
            host=Config.WEBHOOK_HOST,
            port=Config.PORT,
            secret_token=Config.WEBHOOK_SECRET
        )
    else:
        logger.info("ðŸ”„ Iniciando en modo POLLING...")
        # Registrar callbacks de polling
        dp.startup.register(on_startup)
        dp.shutdown.register(on_shutdown)

        # Iniciar polling
        await dp.start_polling(
            bot,
            allowed_updates=dp.resolve_used_update_types(),
            timeout=30,
            drop_pending_updates=True,
            relax_timeout=True
        )
```

NOTE: This adds the infrastructure for webhook mode detection. The on_startup_webhook function defined in this task provides the startup callback. Full webhook implementation with Telegram webhook registration will be completed in a future phase. For now, the mode detection and conditional startup logic are in place.
</action>
  <verify>
```python
# Test mode detection
from main import should_use_webhook
from config import Config

Config.WEBHOOK_MODE = "polling"
assert should_use_webhook() == False

Config.WEBHOOK_MODE = "webhook"
assert should_use_webhook() == True
```
</verify>
  <done>
- should_use_webhook() detects WEBHOOK_MODE from Config
- main() has conditional logic for webhook vs polling mode
- Webhook mode uses dp.start_webhook() with proper configuration
- Polling mode uses existing dp.start_polling() logic
- Logging shows which mode is being used
</done>
</task>

<task type="auto">
  <name>Task 4: Update .env.example with webhook variables</name>
  <files>.env.example</files>
  <action>Add webhook configuration to .env.example:

Add after the ENVIRONMENT section:

```bash
# ===== WEBHOOK CONFIGURATION =====
# Modo de operaciÃ³n: "polling" (default) o "webhook" (Railway)
# Polling: El bot hace requests a Telegram (bueno para desarrollo local)
# Webhook: Telegram envÃ­a updates al bot (bueno para producciÃ³n en Railway)
WEBHOOK_MODE=polling

# Puerto donde el bot escucha en webhook mode
# Railway asigna PORT=8000 automÃ¡ticamente
# No configures esto manualmente en Railway (Railway lo hace)
PORT=8000

# Secret token para validar webhooks (recomendado para producciÃ³n)
# Genera uno seguro: python -c "import secrets; print(secrets.token_urlsafe(32))"
# WEBHOOK_SECRET=your-secret-token-here

# Webhook path (URL path donde Telegram envÃ­a updates)
WEBHOOK_PATH=/webhook

# Webhook base URL (completa: https://your-app.railway.app)
# Solo necesario en webhook mode
# WEBHOOK_BASE_URL=https://your-app.railway.app

# Webhook host (donde el servidor web escucha)
# Default: 0.0.0.0 (acepta conexiones externas)
WEBHOOK_HOST=0.0.0.0
```

Also update the existing Environment section to clarify Railway usage:

```bash
# ===== ENVIRONMENT =====
# Entorno: "production" o "development" (default: development)
# En Railway, configÃºralo como "production" para migraciones automÃ¡ticas
ENV=development
```
</action>
  <verify>grep -E "(WEBHOOK|PORT)" .env.example shows all webhook variables with documentation</verify>
  <done>
- .env.example documents WEBHOOK_MODE with polling/webhook options
- .env.example documents PORT for webhook mode
- .env.example documents WEBHOOK_SECRET with generation command
- .env.example documents WEBHOOK_PATH and WEBHOOK_BASE_URL
- .env.example documents WEBHOOK_HOST
- Comments explain when to use each mode
</done>
</task>

<task type="auto">
  <name>Task 5: Add WEBHOOK_BASE_URL and WEBHOOK_HOST to Config</name>
  <files>config.py</files>
  <action>Add missing webhook configuration to Config:

Add these to the "WEBHOOK CONFIGURATION" section:

```python
# Base URL para webhook (ej: https://your-app.railway.app)
# Railway asigna RAILWAY_PUBLIC_DOMAIN automÃ¡ticamente
WEBHOOK_BASE_URL: str = os.getenv(
    "WEBHOOK_BASE_URL",
    ""
)

# Host donde el servidor web escucha (default: 0.0.0.0)
WEBHOOK_HOST: str = os.getenv("WEBHOOK_HOST", "0.0.0.0")
```

Update get_summary() to show webhook URL in webhook mode:

```python
ðŸ”„ Modo: {cls.WEBHOOK_MODE.upper()}
{f'ðŸ”— Webhook: {cls.WEBHOOK_BASE_URL}{cls.WEBHOOK_PATH}' if cls.WEBHOOK_MODE == 'webhook' and cls.WEBHOOK_BASE_URL else ''}
```

This allows Railway to automatically configure the webhook URL using RAILWAY_PUBLIC_DOMAIN.
</action>
  <verify>
```python
from config import Config

# Test defaults
assert Config.WEBHOOK_BASE_URL == ""
assert Config.WEBHOOK_HOST == "0.0.0.0"
```
</verify>
  <done>
- Config.WEBHOOK_BASE_URL added with default empty string
- Config.WEBHOOK_HOST added with default "0.0.0.0"
- get_summary() shows webhook URL when in webhook mode
- Both can be overridden via environment variables
</done>
</task>

---

## Verification Criteria

**Must-haves (goal-backward verification):**

1. âœ… Config validates all required environment variables on startup (RAIL-04)
   - Test: Missing BOT_TOKEN â†’ Config.validate() returns False with error
   - Test: Missing DATABASE_URL â†’ Config.validate() returns False with error
   - Test: Missing ADMIN_USER_IDS â†’ Config.validate() returns False with error

2. âœ… Config provides clear error messages for missing or invalid variables (RAIL-04)
   - Test: Invalid WEBHOOK_MODE â†’ Error message shows valid options
   - Test: Invalid PORT â†’ Error message shows valid range
   - Test: Missing variables â†’ List of missing variables shown

3. âœ… Bot can switch between polling and webhook modes via WEBHOOK_MODE env var (RAIL-05)
   - Test: WEBHOOK_MODE=polling â†’ Bot starts with polling
   - Test: WEBHOOK_MODE=webhook â†’ Bot starts with webhook (when implemented)

4. âœ… Webhook mode uses PORT env variable for webhook URL (RAIL-05)
   - Test: WEBHOOK_MODE=webhook, PORT=8000 â†’ Webhook configured on port 8000
   - Test: PORT is read from Config.PORT in webhook setup

5. âœ… Polling mode is default for local development (RAIL-05)
   - Test: WEBHOOK_MODE not set â†’ Defaults to "polling"
   - Test: Bot works locally without any webhook configuration

6. âœ… Health check API works in both polling and webhook modes (HEALTH-04)
   - Test: Polling mode â†’ Health API starts on HEALTH_PORT
   - Test: Webhook mode â†’ Health API starts on HEALTH_PORT (same port or different)

---

## Success Metrics

- âœ… All required environment variables are validated before bot starts
- âœ… Clear error messages guide users to fix configuration issues
- âœ… WEBHOOK_MODE defaults to "polling" for local development
- âœ… Webhook mode configuration is ready for Railway deployment
- âœ… Polling mode continues to work for local development
- âœ… Health check API works independently of bot mode

---

## Output

After completion, create `.planning/phases/15-health-check-railway-prep/15-04-SUMMARY.md`
