---
phase: 15-health-check-railway-prep
plan: 15-02
type: execute
wave: 2
depends_on: [15-01]
files_modified:
  - main.py
  - bot/health/runner.py
autonomous: true
must_haves:
  truths:
    - "Bot and health API run concurrently in separate asyncio tasks"
    - "Health API starts on HEALTH_PORT (default 8000) without blocking bot startup"
    - "Both bot and health API share the same event loop"
    - "Graceful shutdown stops both bot and health API cleanly"
    - "Health API continues running even if bot has issues (independent monitoring)"
  artifacts:
    - path: "bot/health/runner.py"
      provides: "Health API server runner with uvicorn"
      min_lines: 50
      contains: ["run_health_api", "start_health_server"]
    - path: "main.py"
      provides: "Concurrent execution of bot and health API"
      contains: ["asyncio.create_task", "start_health_server", "run_health_api"]
  key_links:
    - from: "bot/health/runner.py"
      to: "bot/health/endpoints.py"
      via: "import create_health_app"
      pattern: "from bot.health.endpoints import create_health_app"
    - from: "bot/health/runner.py"
      to: "config.py"
      via: "Config.HEALTH_PORT"
      pattern: "Config\\.HEALTH_PORT"
    - from: "main.py"
      to: "bot/health/runner.py"
      via: "import start_health_server"
      pattern: "from bot.health.runner import"
---

# Plan 15-02: Concurrent Bot and Health API Execution

**Wave:** 2
**Depends on:** Plan 15-01 (FastAPI health check endpoint)

---

## Overview

Implement concurrent execution of the aiogram bot and FastAPI health check API. Both services will run in the same asyncio event loop but as independent tasks, allowing the health endpoint to remain responsive even if the bot experiences issues. The health API will start automatically when the bot starts and shut down gracefully when the bot stops.

---

## Tasks

<task type="auto">
  <name>Task 1: Create health API runner module</name>
  <files>bot/health/runner.py</files>
  <action>Create a new module `bot/health/runner.py` that implements the health API server:

1. **run_health_api(host: str, port: int)** function that:
   - Creates FastAPI app using create_health_app()
   - Configures uvicorn with:
     - host=host, port=port
     - log_level="info" (use uvicorn's logging)
     - access_log=True (log all requests)
     - loop="asyncio" (use existing event loop)
   - Runs uvicorn server asynchronously
   - Logs startup message at INFO level: "üè• Health API running on http://{host}:{port}"
   - Handles KeyboardInterrupt gracefully
   - Returns None (runs forever until stopped)

2. **start_health_server() -> asyncio.Task** function that:
   - Gets port from Config.HEALTH_PORT
   - Gets host from Config.HEALTH_HOST (or default to "0.0.0.0")
   - Creates asyncio task for run_health_api()
   - Returns the task object for tracking
   - Logs at INFO level: "üöÄ Starting health API server..."

3. Add Config.HEALTH_HOST with default "0.0.0.0" to allow external connections (important for Railway health checks)

Use uvicorn.Server with uvicorn.Config for async execution pattern.
</action>
  <verify>
```python
from bot.health.runner import start_health_server, run_health_api
import asyncio

# Test that server can be created
async def test_server():
    task = start_health_server()
    assert task is not None
    assert isinstance(task, asyncio.Task)
    # Cancel immediately to avoid blocking
    task.cancel()
    try:
        await task
    except asyncio.CancelledError:
        pass

asyncio.run(test_server())
```
</verify>
  <done>
- run_health_api() starts uvicorn server with FastAPI app
- start_health_server() creates asyncio task for health API
- Server uses Config.HEALTH_PORT and Config.HEALTH_HOST
- Logs appropriate startup messages
</done>
</task>

<task type="auto">
  <name>Task 2: Add HEALTH_HOST to Config</name>
  <files>config.py</files>
  <action>Add HEALTH_HOST to Config class:

In the "HEALTH CHECK" section (after HEALTH_PORT):
```python
# ===== HEALTH CHECK =====
# Puerto para el endpoint de health check (FastAPI)
# Default: 8000 (no debe colisionar con otros servicios)
HEALTH_PORT: int = int(os.getenv("HEALTH_PORT", "8000"))

# Host para el health check API
# Default: "0.0.0.0" (acepta conexiones externas, necesario para Railway)
HEALTH_HOST: str = os.getenv("HEALTH_HOST", "0.0.0.0")
```

Update get_summary() to include host info:
```python
‚èï Health API: http://{cls.HEALTH_HOST}:{cls.HEALTH_PORT}/health
```
</action>
  <verify>
```python
from config import Config
assert Config.HEALTH_HOST == "0.0.0.0"  # default
```
</verify>
  <done>
- Config.HEALTH_HOST defaults to "0.0.0.0"
- Config.HEALTH_HOST can be overridden via HEALTH_HOST env var
- get_summary() includes full health URL
</done>
</task>

<task type="auto">
  <name>Task 3: Integrate health API startup in main.py</name>
  <files>main.py</files>
  <action>Modify main.py to start health API concurrently with the bot:

1. Add import at top:
```python
from bot.health.runner import start_health_server
```

2. Modify on_startup() to start health server:
   - After bot initialization but before admin notification
   - Start health server in background task
   - Store task reference for graceful shutdown
   - Add to existing try-except error handling

Add this in on_startup() after "Iniciar background tasks":
```python
# Iniciar health check API (corre concurrentemente con el bot)
try:
    health_task = start_health_server()
    logger.info("‚úÖ Health check API iniciado")
except Exception as e:
    logger.error(f"‚ùå Error iniciando health API: {e}")
    logger.warning("‚ö†Ô∏è Bot continuar√° sin health check endpoint")
    health_task = None
```

3. Store health_task in dp.workflow_data for shutdown access:
```python
# Store health task for graceful shutdown
dp.workflow_data['health_task'] = health_task
```

IMPORTANT: Do NOT block bot startup waiting for health API to be fully ready. It can start asynchronously.
</action>
  <verify>
```python
# Verify that health server starts in on_startup
# Check main.py contains:
# - from bot.health.runner import start_health_server
# - health_task = start_health_server() in on_startup()
# - dp.workflow_data['health_task'] = health_task
```
</verify>
  <done>
- main.py imports start_health_server
- on_startup() calls start_health_server() after bot init
- health_task stored in dp.workflow_data for shutdown
- Health API startup errors don't prevent bot from starting
</done>
</task>

<task type="auto">
  <name>Task 4: Implement health API graceful shutdown</name>
  <files>main.py</files>
  <action>Modify on_shutdown() in main.py to stop health API gracefully:

Add this in on_shutdown() after "Detener background tasks" and before "Notificar a admins":
```python
# Detener health check API
health_task = dispatcher.workflow_data.get('health_task')
if health_task and not health_task.done():
    logger.info("üõë Deteniendo health check API...")
    health_task.cancel()
    try:
        await asyncio.wait_for(health_task, timeout=5)
    except (asyncio.CancelledError, asyncio.TimeoutError):
        logger.warning("‚ö†Ô∏è Health API no respondi√≥ a shutdown (timeout)")
    except Exception as e:
        logger.warning(f"‚ö†Ô∏è Error deteniendo health API: {e}")
```

This ensures the health API is properly closed before the bot exits.
</action>
  <verify>
```python
# Verify that on_shutdown() includes health API cleanup
# Check main.py contains:
# - health_task = dispatcher.workflow_data.get('health_task')
# - health_task.cancel()
# - Proper error handling for timeout and exceptions
```
</verify>
  <done>
- on_shutdown() retrieves health_task from workflow_data
- Health API task is cancelled gracefully
- Timeout of 5s prevents hanging shutdown
- Proper error handling for all scenarios
</done>
</task>

<task type="auto">
  <name>Task 5: Test concurrent execution manually</name>
  <files>None</files>
  <action>Manual verification task (no code changes):

1. Start the bot normally: `python main.py`
2. Verify both services start:
   - Bot shows "‚úÖ Bot iniciado y listo para recibir mensajes"
   - Health API shows "üè• Health API running on http://0.0.0.0:8000"
3. Test health endpoint in separate terminal: `curl http://localhost:8000/health`
4. Verify bot still works (send /start to bot)
5. Stop bot with Ctrl+C
6. Verify both services stop cleanly

Document the results in a comment in main.py near the health integration code.
</action>
  <verify>
```bash
# Test commands to run:
python main.py
# In another terminal:
curl http://localhost:8000/health
curl http://localhost:8000/
# Send message to bot in Telegram
# Press Ctrl+C to stop
```
</verify>
  <done>
- Bot and health API start concurrently
- Both services respond to requests independently
- Ctrl+C stops both services gracefully
- No errors in logs during startup/shutdown
</done>
</task>

---

## Verification Criteria

**Must-haves (goal-backward verification):**

1. ‚úÖ Bot and health API run concurrently in separate asyncio tasks (HEALTH-05)
   - Test: Start bot ‚Üí both bot polling and health API start
   - Test: Bot receives messages while health API responds to /health requests

2. ‚úÖ Health API starts on HEALTH_PORT without blocking bot startup (HEALTH-04)
   - Test: Bot startup completes immediately, health API starts in background
   - Test: Bot is ready to receive messages before health API fully initializes

3. ‚úÖ Both bot and health API share the same event loop
   - Test: asyncio.get_running_loop() returns same loop in both contexts
   - Test: Tasks are created in same event loop

4. ‚úÖ Graceful shutdown stops both bot and health API cleanly
   - Test: Ctrl+C ‚Üí both services stop, no "address already in use" errors on restart
   - Test: health_task.cancel() called in on_shutdown()

5. ‚úÖ Health API continues running even if bot has issues (independent monitoring)
   - Test: Simulate bot issue (e.g., network timeout) ‚Üí health API still responds
   - Test: Health check can report bot as unhealthy while API remains responsive

---

## Success Metrics

- ‚úÖ Bot starts and processes messages normally
- ‚úÖ Health API is accessible on configured port
- ‚úÖ GET /health returns valid response while bot is running
- ‚úÖ No performance degradation in bot due to health API
- ‚úÖ Both services start within 5 seconds of execution
- ‚úÖ Clean shutdown with no orphaned processes or port conflicts

---

## Output

After completion, create `.planning/phases/15-health-check-railway-prep/15-02-SUMMARY.md`
