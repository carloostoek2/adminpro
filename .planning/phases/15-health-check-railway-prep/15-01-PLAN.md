---
phase: 15-health-check-railway-prep
plan: 15-01
type: execute
wave: 1
depends_on: [14]
files_modified:
  - requirements.txt
  - bot/health/
  - bot/health/__init__.py
  - bot/health/check.py
  - bot/health/endpoints.py
autonomous: true
must_haves:
  truths:
    - "FastAPI application with /health endpoint returns 200 OK when bot and DB are healthy"
    - "Health check returns 503 Service Unavailable when database connection fails"
    - "Health check verifies both bot token validity and database connectivity"
    - "FastAPI runs on separate port (configurable via HEALTH_PORT env var, default 8000)"
    - "Health check includes status of bot initialization and database connection"
  artifacts:
    - path: "bot/health/check.py"
      provides: "Health check functions for bot and database status"
      min_lines: 80
      contains: ["check_bot_health", "check_database_health", "HealthStatus"]
    - path: "bot/health/endpoints.py"
      provides: "FastAPI application with /health endpoint"
      min_lines: 60
      contains: ["create_health_app", "/health"]
    - path: "requirements.txt"
      provides: "FastAPI and uvicorn dependencies"
      contains: ["fastapi==0.109.0", "uvicorn[standard]==0.27.0"]
  key_links:
    - from: "bot/health/endpoints.py"
      to: "bot/health/check.py"
      via: "import check_bot_health, check_database_health"
      pattern: "from bot.health.check import"
    - from: "bot/health/endpoints.py"
      to: "config.py"
      via: "Config.BOT_TOKEN, Config.DATABASE_URL"
      pattern: "Config\\.(BOT_TOKEN|DATABASE_URL)"
    - from: "bot/health/check.py"
      to: "bot/database/engine.py"
      via: "get_engine() for database connectivity test"
      pattern: "from bot.database.engine import get_engine"
---

# Plan 15-01: FastAPI Health Check Endpoint with Bot and Database Status

**Wave:** 1
**Depends on:** Phase 14 (Database Migration Foundation)

---

## Overview

Implement a FastAPI health check endpoint that monitors both the bot's connectivity to Telegram and the database connection status. The health check will return 200 OK when all systems are operational and 503 Service Unavailable when any component is failing. This endpoint will be used by Railway's health monitoring system to ensure the bot is running correctly.

---

## Tasks

<task type="auto">
  <name>Task 1: Update requirements.txt with FastAPI and uvicorn</name>
  <files>requirements.txt</files>
  <action>Add FastAPI and uvicorn to requirements.txt:

```diff
# Bot Framework
aiogram>=3.24.0

# Database
sqlalchemy==2.0.25
aiosqlite==0.19.0
asyncpg==0.29.0

# Health Check
+fastapi==0.109.0
+uvicorn[standard]==0.27.0

# Background Tasks
APScheduler==3.10.4
tzdata>=2024.1
```

Add these in a new "Health Check" section after Database but before Background Tasks.
</action>
  <verify>grep -E "(fastapi|uvicorn)" requirements.txt returns both dependencies</verify>
  <done>fastapi==0.109.0 and uvicorn[standard]==0.27.0 are present in requirements.txt</done>
</task>

<task type="auto">
  <name>Task 2: Create health check utilities module</name>
  <files>bot/health/check.py</files>
  <action>Create a new module `bot/health/check.py` that implements health check functions:

1. **HealthStatus enum** with values: HEALTHY, DEGRADED, UNHEALTHY

2. **check_bot_health() -> HealthStatus** function that:
   - Validates Config.BOT_TOKEN is present
   - Attempts to verify bot token with Telegram API (if possible)
   - Returns HealthStatus.HEALTHY if token is valid
   - Returns HealthStatus.UNHEALTHY if token is missing or invalid
   - Logs at INFO level when checking, DEBUG when successful, WARNING when failed

3. **check_database_health() -> HealthStatus** function that:
   - Checks if database engine is initialized (get_engine())
   - Attempts to execute a simple query (SELECT 1 or equivalent)
   - Returns HealthStatus.HEALTHY if database is responsive
   - Returns HealthStatus.UNHEALTHY if engine not initialized or query fails
   - Logs at INFO level when checking, DEBUG when successful, ERROR when failed

4. **get_health_summary() -> dict** function that:
   - Calls check_bot_health() and check_database_health()
   - Returns a dict with overall status and component statuses:
   ```python
   {
       "status": "healthy" | "degraded" | "unhealthy",
       "timestamp": "2024-01-28T12:00:00Z",
       "components": {
           "bot": "healthy" | "unhealthy",
           "database": "healthy" | "unhealthy"
       }
   }
   ```

Use datetime.utcnow() for timestamp. Include comprehensive docstrings and type hints.
</action>
  <verify>
```python
from bot.health.check import check_bot_health, check_database_health, get_health_summary, HealthStatus

# Test bot health check
bot_status = check_bot_health()
assert bot_status in [HealthStatus.HEALTHY, HealthStatus.UNHEALTHY]

# Test database health check
db_status = check_database_health()
assert db_status in [HealthStatus.HEALTHY, HealthStatus.UNHEALTHY]

# Test health summary
summary = get_health_summary()
assert "status" in summary
assert "components" in summary
assert "bot" in summary["components"]
assert "database" in summary["components"]
```
</verify>
  <done>
- check_bot_health() returns HealthStatus.HEALTHY when token is valid
- check_database_health() returns HealthStatus.HEALTHY when DB is responsive
- get_health_summary() returns dict with status, timestamp, and components
- Health checks log appropriately at each level
</done>
</task>

<task type="auto">
  <name>Task 3: Create FastAPI health endpoints module</name>
  <files>bot/health/endpoints.py</files>
  <action>Create a new module `bot/health/endpoints.py` that implements FastAPI endpoints:

1. **create_health_app() -> FastAPI** function that:
   - Creates a FastAPI app instance
   - Sets title="Lucien Bot Health", version="1.0.0"
   - Returns the configured FastAPI app

2. **@app.get("/health")** endpoint that:
   - Calls get_health_summary() from bot.health.check
   - Returns 200 OK with health summary when status is "healthy" or "degraded"
   - Returns 503 Service Unavailable when status is "unhealthy"
   - Returns JSON response with appropriate status code
   - Logs each health check request at INFO level

3. **@app.get("/")** root endpoint that:
   - Returns simple JSON: {"service": "lucien-bot-health", "status": "operational"}
   - Always returns 200 OK
   - Useful for basic connectivity testing

Include proper imports, type hints, and docstrings. The FastAPI app should be standalone and not interfere with the bot's aiogram dispatcher.
</action>
  <verify>
```python
from bot.health.endpoints import create_health_app
from fastapi.testclient import TestClient

app = create_health_app()
client = TestClient(app)

# Test root endpoint
response = client.get("/")
assert response.status_code == 200
assert response.json()["service"] == "lucien-bot-health"

# Test health endpoint
response = client.get("/health")
assert response.status_code in [200, 503]
assert "status" in response.json()
assert "components" in response.json()
```
</verify>
  <done>
- create_health_app() returns FastAPI instance
- GET /health returns 200 when healthy, 503 when unhealthy
- GET / returns 200 with service info
- Health check returns JSON with status and components
</done>
</task>

<task type="auto">
  <name>Task 4: Create health module __init__.py</name>
  <files>bot/health/__init__.py</files>
  <action>Create `bot/health/__init__.py` that exports health check components:

```python
"""
Health check utilities for bot monitoring.

Provides FastAPI endpoints and health check functions for monitoring
bot status, database connectivity, and overall system health.
"""

from bot.health.check import (
    HealthStatus,
    check_bot_health,
    check_database_health,
    get_health_summary
)

from bot.health.endpoints import create_health_app

__all__ = [
    "HealthStatus",
    "check_bot_health",
    "check_database_health",
    "get_health_summary",
    "create_health_app"
]
```
</action>
  <verify>python -c "from bot.health import create_health_app, get_health_summary; print('Exports work')" succeeds</verify>
  <done>
- __init__.py exports all health check components
- Imports work correctly from bot.health namespace
- Module docstring explains purpose
</done>
</task>

<task type="auto">
  <name>Task 5: Update Config with HEALTH_PORT environment variable</name>
  <files>config.py</files>
  <action>Add HEALTH_PORT to Config class:

1. Add class attribute:
```python
# ===== HEALTH CHECK =====
# Puerto para el endpoint de health check (FastAPI)
# Default: 8000 (no debe colisionar con otros servicios)
HEALTH_PORT: int = int(os.getenv("HEALTH_PORT", "8000"))
```

2. Update get_summary() to include health port info:
```python
# Add to the summary output
⏕ Health Port: {cls.HEALTH_PORT}
```

This will allow Railway to configure the health check port via environment variable.
</action>
  <verify>
```python
from config import Config
assert Config.HEALTH_PORT == 8000  # default
import os
os.environ["HEALTH_PORT"] = "9000"
# Reload config to test
assert Config.HEALTH_PORT == 9000
```
</verify>
  <done>
- Config.HEALTH_PORT defaults to 8000
- Config.HEALTH_PORT can be overridden via HEALTH_PORT env var
- get_summary() includes health port information
</done>
</task>

---

## Verification Criteria

**Must-haves (goal-backward verification):**

1. ✅ FastAPI application with /health endpoint returns 200 OK when bot and DB are healthy (HEALTH-01)
   - Test: Start health API, call GET /health → 200 OK with status: "healthy"
   - Test: Response includes components.bot and components.database

2. ✅ Health check returns 503 Service Unavailable when database connection fails (HEALTH-03)
   - Test: Stop database, call GET /health → 503 with status: "unhealthy"
   - Test: Response includes details about which component failed

3. ✅ Health check verifies bot token validity (HEALTH-01)
   - Test: Invalid BOT_TOKEN → check_bot_health() returns UNHEALTHY
   - Test: Valid BOT_TOKEN → check_bot_health() returns HEALTHY

4. ✅ Health check verifies database connectivity (HEALTH-02)
   - Test: Database running → check_database_health() returns HEALTHY
   - Test: Database down → check_database_health() returns UNHEALTHY

5. ✅ FastAPI runs on configurable port (HEALTH-04)
   - Test: Default HEALTH_PORT=8000 → FastAPI starts on port 8000
   - Test: HEALTH_PORT=9000 → FastAPI starts on port 9000

6. ✅ Health check includes timestamp and component statuses
   - Test: GET /health returns JSON with timestamp, status, and components dict
   - Test: Timestamp format is ISO 8601 (UTC)

---

## Success Metrics

- ✅ FastAPI app starts successfully on configured port
- ✅ GET /health returns 200 OK when all components are healthy
- ✅ GET /health returns 503 when any component is unhealthy
- ✅ Health check executes quickly (< 1s for healthy state)
- ✅ Proper logging of health check requests and results
- ✅ Health check can be called independently without affecting bot operation

---

## Output

After completion, create `.planning/phases/15-health-check-railway-prep/15-01-SUMMARY.md`
