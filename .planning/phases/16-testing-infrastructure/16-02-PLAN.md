---
phase: 16-testing-infrastructure
plan: 02
type: execute
wave: 1
depends_on: [16-01]
files_modified:
  - tests/conftest.py
  - tests/fixtures/__init__.py
  - tests/fixtures/database.py
  - tests/fixtures/services.py
autonomous: true

must_haves:
  truths:
    - test_db fixture creates isolated database
    - mock_bot fixture provides mocked Telegram bot
    - container fixture provides ServiceContainer with dependencies
    - All fixtures are reusable across test files
  artifacts:
    - path: tests/fixtures/database.py
      provides: test_db and test_session fixtures
    - path: tests/fixtures/services.py
      provides: mock_bot and container fixtures
  key_links:
    - from: container fixture
      to: ServiceContainer
      via: test_session and mock_bot injection
---

# Task 16-02: Core Test Fixtures

## Objective
Create comprehensive, reusable fixtures for all tests: test_db (in-memory database), mock_bot (Telegram bot mock), and container (ServiceContainer with injected dependencies).

## Current State Analysis
- conftest.py has basic mock_bot fixture
- No dedicated fixtures module structure
- Database setup uses file-based SQLite (not isolated)
- No container fixture exists

## Requirements (TESTINF-02)
- Fixtures creados (test_db, mock_bot, container)
- Fixtures must be reusable across all test files
- Proper cleanup after each test

## Implementation Steps

### 1. Create Fixtures Module Structure
```
tests/
‚îú‚îÄ‚îÄ conftest.py              # Updated with new fixtures
‚îî‚îÄ‚îÄ fixtures/
    ‚îú‚îÄ‚îÄ __init__.py          # Export all fixtures
    ‚îú‚îÄ‚îÄ database.py          # test_db fixture
    ‚îî‚îÄ‚îÄ services.py          # container fixture + mock_bot
```

### 2. Create tests/fixtures/database.py
```python
"""
Database fixtures for testing.

Provides isolated in-memory database for each test.
"""
import pytest
import pytest_asyncio
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession, async_sessionmaker

from bot.database.base import Base
from bot.database.models import BotConfig


@pytest_asyncio.fixture
async def test_db():
    """
    Fixture: Provides an isolated in-memory database for each test.

    Creates a new SQLite in-memory database, creates all tables,
    yields the session factory, then cleans up after the test.

    Yields:
        async_sessionmaker: Session factory bound to test database
    """
    # Create in-memory engine
    engine = create_async_engine(
        "sqlite+aiosqlite:///:memory:",
        echo=False,
        future=True
    )

    # Create all tables
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)

    # Create session factory
    session_factory = async_sessionmaker(
        engine,
        class_=AsyncSession,
        expire_on_commit=False
    )

    # Create BotConfig singleton
    async with session_factory() as session:
        config = BotConfig(
            id=1,
            wait_time_minutes=5,
            vip_reactions=["üî•", "‚ù§Ô∏è"],
            free_reactions=["üëç"],
            subscription_fees={"monthly": 10, "yearly": 100}
        )
        session.add(config)
        await session.commit()

    yield session_factory

    # Cleanup
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.drop_all)
    await engine.dispose()


@pytest_asyncio.fixture
async def test_session(test_db):
    """
    Fixture: Provides an active database session for a test.

    Automatically commits or rolls back based on test outcome.

    Args:
        test_db: The test_db fixture (session factory)

    Yields:
        AsyncSession: Active database session
    """
    async with test_db() as session:
        yield session
        # Rollback after test to ensure isolation
        await session.rollback()
```

### 3. Create tests/fixtures/services.py
```python
"""
Service fixtures for testing.

Provides mocked and real service containers for tests.
"""
import pytest
import pytest_asyncio
from unittest.mock import AsyncMock, Mock

from bot.services.container import ServiceContainer


@pytest.fixture
def mock_bot():
    """
    Fixture: Mock del bot de Telegram.

    Provides mock of required Telegram API methods:
    - get_chat
    - get_chat_member
    - create_chat_invite_link
    - ban_chat_member
    - unban_chat_member
    - send_message
    - get_me (returns bot info)
    """
    bot = Mock()
    bot.id = 123456789
    bot.username = "test_bot"
    bot.first_name = "Test Bot"

    # Mock async methods
    bot.get_chat = AsyncMock()
    bot.get_chat_member = AsyncMock()
    bot.create_chat_invite_link = AsyncMock(return_value=Mock(
        invite_link="https://t.me/test/invite123",
        expire_date=None,
        member_limit=None
    ))
    bot.ban_chat_member = AsyncMock()
    bot.unban_chat_member = AsyncMock()
    bot.send_message = AsyncMock()
    bot.get_me = AsyncMock(return_value=Mock(
        id=bot.id,
        username=bot.username,
        first_name=bot.first_name
    ))

    return bot


@pytest_asyncio.fixture
async def container(test_session, mock_bot):
    """
    Fixture: ServiceContainer with test database and mock bot.

    Provides a fully configured ServiceContainer ready for testing:
    - Connected to in-memory test database
    - Mocked Telegram bot
    - All services available via lazy loading

    Args:
        test_session: Database session fixture
        mock_bot: Mocked Telegram bot fixture

    Yields:
        ServiceContainer: Configured container for testing
    """
    container = ServiceContainer(test_session, mock_bot)
    yield container


@pytest_asyncio.fixture
async def container_with_preload(container):
    """
    Fixture: ServiceContainer with critical services preloaded.

    Use this when you need immediate access to subscription/config
    services without triggering lazy loading during the test.

    Yields:
        ServiceContainer: Container with subscription and config loaded
    """
    await container.preload_critical_services()
    yield container
```

### 4. Update tests/fixtures/__init__.py
```python
"""
Test fixtures package.

Import all fixtures to make them available via conftest.py.
"""
from tests.fixtures.database import test_db, test_session
from tests.fixtures.services import mock_bot, container, container_with_preload

__all__ = [
    "test_db",
    "test_session",
    "mock_bot",
    "container",
    "container_with_preload",
]
```

### 5. Update tests/conftest.py
Add imports for new fixtures:
```python
# Import all fixtures from fixtures package
from tests.fixtures import *

# Keep existing semantic assertion fixtures
# (assert_greeting_present, assert_lucien_voice, assert_time_aware)
```

## Verification Criteria

1. **test_db Fixture Works**: Creates isolated in-memory database
2. **test_session Fixture Works**: Provides active session with rollback
3. **mock_bot Fixture Works**: Provides properly mocked Telegram bot
4. **container Fixture Works**: Provides ServiceContainer with dependencies
5. **Fixtures Are Reusable**: Can be used across multiple test files

## must_haves for Goal Verification

```python
# These must be TRUE for phase completion:

# 1. test_db creates isolated database
async def test_db_isolation(test_db):
    """Each test gets its own database"""
    async with test_db() as session:
        result = await session.execute(text("SELECT 1"))
        assert result.scalar() == 1

# 2. test_session provides active session
async def test_session_works(test_session):
    """Session is active and usable"""
    from bot.database.models import BotConfig
    config = await test_session.get(BotConfig, 1)
    assert config is not None
    assert config.id == 1

# 3. mock_bot has all required methods
def test_mock_bot_has_methods(mock_bot):
    """Mock bot has all Telegram API methods"""
    required_methods = [
        'get_chat', 'get_chat_member', 'create_chat_invite_link',
        'ban_chat_member', 'unban_chat_member', 'send_message', 'get_me'
    ]
    for method in required_methods:
        assert hasattr(mock_bot, method)
        assert callable(getattr(mock_bot, method))

# 4. container has all services
async def test_container_has_services(container):
    """Container provides access to all services"""
    # Trigger lazy loading
    _ = container.subscription
    _ = container.config
    _ = container.channel

    loaded = container.get_loaded_services()
    assert 'subscription' in loaded
    assert 'config' in loaded
    assert 'channel' in loaded
```

## Success Criteria
- [ ] tests/fixtures/database.py created with test_db and test_session
- [ ] tests/fixtures/services.py created with mock_bot and container
- [ ] tests/fixtures/__init__.py exports all fixtures
- [ ] conftest.py imports fixtures from fixtures package
- [ ] All fixtures work in isolation tests
- [ ] Existing tests updated to use new fixtures (if needed)
