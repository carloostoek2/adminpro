---
phase: 16-testing-infrastructure
plan: 04
type: execute
wave: 2
depends_on: [16-03]
files_modified:
  - tests/fixtures/database.py
  - tests/test_infrastructure/test_isolation.py
autonomous: true

must_haves:
  truths:
    - Transaction rollback works after each test
    - Data from one test doesn't persist to another
    - BotConfig modifications are rolled back
    - Sessions are properly closed after tests
  artifacts:
    - path: tests/test_infrastructure/test_isolation.py
      provides: isolation verification tests
  key_links:
    - from: test_session fixture
      to: session.rollback()
      via: fixture cleanup
---

# Task 16-04: Test Isolation

## Objective
Ensure complete test isolation with proper cleanup between tests. Each test must start with a clean state and not be affected by previous tests.

## Current State Analysis
- Current tests use file-based database with shared state
- No transaction rollback between tests
- Data from one test can affect others
- No verification of isolation exists

## Requirements (TESTINF-04)
- Aislamiento de tests (cleanup completo entre tests)
- Transaction rollback after each test
- No shared state between tests
- Deterministic test execution order

## Implementation Steps

### 1. Implement Transaction-Based Isolation
Update tests/fixtures/database.py to ensure proper isolation:

```python
@pytest_asyncio.fixture
async def test_session(test_db):
    """
    Fixture: Provides an isolated database session.

    Uses nested transactions to ensure complete isolation:
    - Outer transaction is never committed
    - Inner transaction (test operations) is rolled back
    - Database is clean for each test
    """
    async with test_db() as session:
        # Begin nested transaction
        await session.begin_nested()

        yield session

        # Rollback nested transaction
        await session.rollback()
```

### 2. Create Isolation Verification Tests
Create tests/test_infrastructure/test_isolation.py:

```python
"""
Test Isolation Verification.

These tests verify that the test infrastructure properly isolates
each test from others. If isolation fails, these tests will fail.
"""
import pytest
from datetime import datetime, timedelta
from bot.database.models import VIPSubscriber, InvitationToken, FreeChannelRequest, BotConfig


class TestDatabaseIsolation:
    """Verify each test gets a clean database."""

    async def test_isolation_vip_subscriber_1(self, test_session):
        """Create a VIP subscriber."""
        subscriber = VIPSubscriber(
            user_id=1000001,
            username="isolation_test_1",
            expires_at=datetime.utcnow() + timedelta(days=30),
            status="active"
        )
        test_session.add(subscriber)
        await test_session.commit()

        # Verify exists in this test
        result = await test_session.get(VIPSubscriber, 1000001)
        assert result is not None
        assert result.username == "isolation_test_1"

    async def test_isolation_vip_subscriber_2(self, test_session):
        """Subscriber from test_1 should NOT exist here."""
        result = await test_session.get(VIPSubscriber, 1000001)
        assert result is None, "Database isolation failed - data leaked from previous test"

    async def test_isolation_invitation_token_1(self, test_session):
        """Create an invitation token."""
        token = InvitationToken(
            token="ISOLATION_TOKEN_123",
            generated_by=999999,
            expires_at=datetime.utcnow() + timedelta(hours=24),
            is_used=False,
            duration_hours=168
        )
        test_session.add(token)
        await test_session.commit()

        result = await test_session.execute(
            select(InvitationToken).where(InvitationToken.token == "ISOLATION_TOKEN_123")
        )
        assert result.scalar_one_or_none() is not None

    async def test_isolation_invitation_token_2(self, test_session):
        """Token from test_1 should NOT exist here."""
        from sqlalchemy import select
        result = await test_session.execute(
            select(InvitationToken).where(InvitationToken.token == "ISOLATION_TOKEN_123")
        )
        assert result.scalar_one_or_none() is None, "Token isolation failed"

    async def test_isolation_free_request_1(self, test_session):
        """Create a free channel request."""
        request = FreeChannelRequest(
            user_id=2000001,
            username="free_isolation_test",
            requested_at=datetime.utcnow(),
            status="pending"
        )
        test_session.add(request)
        await test_session.commit()

        result = await test_session.get(FreeChannelRequest, 1)
        assert result is not None

    async def test_isolation_free_request_2(self, test_session):
        """Request from test_1 should NOT exist here."""
        # Query all free requests
        from sqlalchemy import select
        result = await test_session.execute(select(FreeChannelRequest))
        requests = result.scalars().all()

        # Should be empty (or only have data created in this test)
        usernames = [r.username for r in requests]
        assert "free_isolation_test" not in usernames, "Free request isolation failed"


class TestBotConfigIsolation:
    """Verify BotConfig singleton behavior in tests."""

    async def test_botconfig_is_singleton_within_test(self, test_session):
        """BotConfig should be the same record within a test."""
        config1 = await test_session.get(BotConfig, 1)
        config2 = await test_session.get(BotConfig, 1)

        assert config1 is config2 or config1.id == config2.id == 1

    async def test_botconfig_modifications_rolled_back(self, test_session):
        """Modifications to BotConfig should not persist between tests."""
        config = await test_session.get(BotConfig, 1)
        original_wait_time = config.wait_time_minutes

        # Modify
        config.wait_time_minutes = 999
        await test_session.commit()

        # Verify modified
        config = await test_session.get(BotConfig, 1)
        assert config.wait_time_minutes == 999

    async def test_botconfig_reset_in_next_test(self, test_session):
        """BotConfig should have default values (modifications rolled back)."""
        config = await test_session.get(BotConfig, 1)

        # Should have default value, not 999 from previous test
        assert config.wait_time_minutes == 5, \
            f"Expected wait_time=5, got {config.wait_time_minutes}. Isolation failed!"


class TestSessionIsolation:
    """Verify session-level isolation."""

    async def test_session_does_not_see_uncommitted(self, test_session, test_db):
        """Uncommitted data should not be visible to other sessions."""
        # Add data in this session (but don't commit yet)
        subscriber = VIPSubscriber(
            user_id=3000001,
            expires_at=datetime.utcnow() + timedelta(days=30),
            status="active"
        )
        test_session.add(subscriber)
        # Note: NOT committed

        # Create a new session - should not see uncommitted data
        async with test_db() as new_session:
            result = await new_session.get(VIPSubscriber, 3000001)
            assert result is None, "Uncommitted data visible to other sessions"

        # Now commit and verify visible
        await test_session.commit()
        async with test_db() as new_session:
            result = await new_session.get(VIPSubscriber, 3000001)
            assert result is not None
```

### 3. Add Cleanup Verification
```python
# tests/test_infrastructure/test_cleanup.py
"""
Test Cleanup Verification.

Ensures that all resources are properly cleaned up after tests.
"""
import gc
import pytest


class TestResourceCleanup:
    """Verify resources are cleaned up after tests."""

    async def test_database_connections_closed(self, test_engine):
        """Verify database connections are closed after test."""
        # Engine should be usable during test
        from sqlalchemy import text
        async with test_engine.connect() as conn:
            result = await conn.execute(text("SELECT 1"))
            assert result.scalar() == 1

        # After test, engine will be disposed by fixture cleanup

    async def test_sessions_closed(self, test_db):
        """Verify sessions are properly closed."""
        async with test_db() as session:
            from bot.database.models import BotConfig
            config = await session.get(BotConfig, 1)
            assert config is not None

        # Session should be closed after exiting context
        assert not session.is_active

    async def test_no_memory_leaks(self, container):
        """Verify ServiceContainer doesn't leak memory."""
        # Load some services
        _ = container.subscription
        _ = container.config
        _ = container.channel

        loaded = container.get_loaded_services()
        assert len(loaded) == 3

        # Container will be garbage collected after test
        # (no explicit cleanup needed for in-memory objects)
```

## Verification Criteria

1. **Transaction Rollback Works**: Changes in one test don't persist
2. **Database Isolation**: Each test sees only its own data
3. **BotConfig Reset**: Modifications to singleton are rolled back
4. **Session Cleanup**: Sessions are properly closed
5. **No Memory Leaks**: Resources are garbage collected

## must_haves for Goal Verification

```python
# These must be TRUE for phase completion:

# 1. VIP subscriber isolation
async def test_vip_isolation(test_session):
    """VIP data is isolated between tests"""
    from datetime import datetime, timedelta

    # Test 1: Create
    sub = VIPSubscriber(
        user_id=12345,
        expires_at=datetime.utcnow() + timedelta(days=1),
        status="active"
    )
    test_session.add(sub)
    await test_session.commit()

    # Verify exists
    result = await test_session.get(VIPSubscriber, 12345)
    assert result is not None

# In a SEPARATE test file:
async def test_vip_isolation_verify(test_session):
    """Previous test's data should not exist"""
    result = await test_session.get(VIPSubscriber, 12345)
    assert result is None  # Isolation confirmed

# 2. BotConfig rollback
async def test_config_modification(test_session):
    """Modify BotConfig"""
    config = await test_session.get(BotConfig, 1)
    config.wait_time_minutes = 999
    await test_session.commit()

# In a SEPARATE test file:
async def test_config_rollback(test_session):
    """BotConfig should have default value"""
    config = await test_session.get(BotConfig, 1)
    assert config.wait_time_minutes == 5  # Rolled back
```

## Success Criteria
- [ ] Transaction rollback works after each test
- [ ] VIP subscriber created in test_1 doesn't exist in test_2
- [ ] Invitation token created in test_1 doesn't exist in test_2
- [ ] Free request created in test_1 doesn't exist in test_2
- [ ] BotConfig modifications are rolled back between tests
- [ ] Sessions are properly closed after tests
- [ ] All isolation tests pass
